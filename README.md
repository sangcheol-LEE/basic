# 유동적인 데이터 렌더링

1. 초기 상태 설정하기

2. 데이터 추가 기능 구현하기

3. 데이터 제거 기능 구현하기

# 라이프 사이클

- 라이프 사이클은 총 세 가지, 즉 마운트, 업데이트, 언마운트 카테고리로 나눕니다.

1. 마운트 - Dom이 생성되고 웹 브라우저상에 나타나는 것
2. 언마운트 - 페이지에서 컴포넌트가 사라짐

3. 업데이트 - 리렌더링 되며 컴포넌트 정보를 업데이트 합니다.

- 컴포넌트는 다음 과 같은 총 네가지 경우에 업데이트 됩니다.

* props가 바뀔 때
* state가 바뀔 때
* 부모 컴포넌트가 리렌더링 될 때
* this.forceUpdate로 강제로 렌더링을 트리거할 때

# Hooks \*\*\*\*

## useState

- 함수형 컴포넌트에서 상태를 관리하기 위해 사용함.
- useState 함수의 파라미터에는 상태의 기본 값을 넣는다.
- 함수가 호출되면 배열을 반환
- 첫 번쨰 원소는 상태 값, 두 번째 원소는 상태를 설정하는 함수

### 하나의 useState 함수는 하나의 상태 값만 관리할 수 있습니다.

## useEffect

- 컴포넌트가 렌더링 될 때마다 특정 작업을 수행하도록 설정할 수 있는 Hook
- componentDidMount 와 componentDidUpdate를 합칩 형태로 봐도 무방하다.

* 마운트 될 때만 실행하고 싶을 때

- 함수의 두번째 파라미터로 비어 있는 배열을 넣어 주면 됩니다.

* 특정 값이 업데이트될 때만 실행하고 싶을 때

- useEffect의 두 번째 파라미터로 전달되는 배열 안에 검사하고 싶은 값을 넣어 주면 됩니다.

* 뒷정리 하기

- useEffect는 기본적으로 렌더링되고 난 직후마다 실행, 의존성 배열안에 무엇을 넣느냐에 따라 실행되는 조건이 달라진다.
- 컴포넌트가 언마운트 되기 전이나 업데이트 되기 직전에 어떠한 작업을 수행하고 싶다면 useEffect에서 뒷정리(clean up) 함수를 반환해야 함

# useMemo

- useMemo를 사용하면 함수형 컴포넌트 내부에서 발생하는 연산을 최적화할 수 있습니다.
- 렌더링하는 과정에서 특정 값이 바뀌었을 때만 연산을 실행하고, 원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식

# useCallback

- 의존성 배열안에는 어떤 값이 바뀌었을 때 함수를 새로 생성해야 하는지 명시
- 빈 배열을 넣게 되면 컴포넌트가 렌더링 될 때 마다 만들었던 함수를 계속해서 재사용하게 되며 배열안에 스테이트 값을 넣게 되면 스테이트 내용이 바뀌거나 새로운 항목이 추가될 때 새로 만들어진 함수를 사용합니다.
- 함수 내부에서 상태 값에 의존해야 할 때는 그 값을 반드시 두 번째 파라미터 안에 포함시켜 주어야 합니다.
- 기존 값을 조회해야만 결과를 출력할 수 있는 경우는 꼭 의존성 배열안에 알맞은 값 (참고 가능 한 값)을 넣어줘야 합니다.

# useRef

- 함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해줌
- ref 안의 값이 바뀌어도 컴포넌가 렌더링되지 않는다는 점은 주의해야 합니다.
